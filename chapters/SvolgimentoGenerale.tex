\chapter{Livesignage su WebOs}\label{svolgimento}
\section{In Breve}
Descrizione del lavoro svolto: \edit{portare l'applicazione già esistente per i dispositivi Samsung sui dispositivi LG}, difficoltà incontrate e soluzioni trovate, modifiche all'applicazione pre-esistente. Descrizione della fase di testing finale.

\section{Fase di analisi}

Nelle prime fasi del tirocinio il lavoro ha riguardato l'analisi dell'applicazione preesistente, della documentazione delle interfacce messe a disposizione da LG e lo studio dei linguaggi di programmazione utilizzati (vedi \ref*{linguaggi}).

Nella Fig.\ref*{fig:architettura_2} è presentato uno schema dell'architettura dell'applicazione lato client in cui sono mostrate le componenti principali: Livesignage, il sistema operativo e il web server che ospita il back office.

\begin{itemize}
    \item Web server: qui vengono salvati in un database MySQL tutte le informazioni degli utenti, dei dispositivi e le playlist create, tutte queste informazioni vengono elaborate e inviate ai client attraverso una socket;
    \item Livesignage: dopo aver aperto stabilito il canale di comunicazione con il web server resta in attesa dei messaggi da questo inviati e si occupa di svolgere le operazioni richieste comunicando, tramite le interfacce di sistema, con il sistema operativo sottostante.
    \item \tomodify{Sistema operativo: riceve le richieste da parte dell'applicazione e una volta effettuate le operazioni chiama una funzione di callback definita precedentemente su cui è inviata la risposta.}
\end{itemize}

Gli altri componenti del sistema sono: il database principale su cui viene salvato il codice HTML delle playlist, il database dei log in cui sono scritti i messaggi di errore in modo che siano successivamente \tomodify{scaricabili} dal creatore di contenuti e la cartella degli assets nella quale vengono salvate le immagini e i video delle playlist create in modo che queste possano essere visualizzate anche offline.

\subsection{Codice Livesignage}

Di seguito è presentata brevemente la struttura dell'applicazione.

\subsubsection{Suddivisione del codice}

Nella cartella principale sono presenti 3 file HTML: 
\begin{itemize}
    \item index.html: è la prima pagina ad essere caricata e si occupa di chiamare le funzioni Javascript per controllare se il device sia stato precedentemente associato a Livesignage.
    \item noAssociation.html: questa pagina viene caricata nel caso che il dispositivo non sia associato e mostra un codice univoco per l'associazione.
    \item display.html: questa è la pagina in cui viene iniettato il codice delle playlist e dei plugin.
\end{itemize}

Il resto dei file fondamentali si trova nella cartella js, qui sono raccolti gli script e le classi necessarie al corretto svolgimento dell'applicazione:

\begin{itemize}
    \item association.js: classe che controlla e gestisce l'associazione del device;
    \item connection.js: i metodi di questa classe vengono chiamati ciclicamente per verificare lo stato della connessione;
    \item db.js: classe che si occupa della gestione del database principale, verrà vista in maniera più approfondita ( insieme a dblog.js ) in \ref*{database};
    \item dblog.js: qui è contenuta la gestione del database degli errori;
    \item display.js: in questa classe sono definiti i metodi che implementano la comunicazione con il sistema operativo attraverso le API. Alcune di queste implementazioni verranno \tomodify{evidenziate} in \ref*{webos_doc};
    \item filemanager.js: si occupa della gestione del file system del sistema e del download e della cancellazione degli assets;
    \item livesignage.js: in questa classe sono contenuti i metodi per la visualizzazione delle playlist, la gestione di alcuni comandi ricevuti dal server come il cambio di slide e il passaggio alla visualizzazione dell'ingresso HDMI e le richieste di salvataggio e cancellazione delle playlist dal database;
    \item log.js: qui sono presenti i metodi per la creazione dei messaggi di errore e l'invio di questi al back office in modo che possano essere visualizzati dal cliente;
    \item main.js: questo è lo script principale che si occupa di chiamare le altre classi, in particolare controlla se sia necessario scaricare un aggiornamento dell'applicazione o del firmware del sistema operativo (vedi \ref*{update}), chiama a intervalli di tempo i metodi per il controllo della connessione, invoca i metodi che si occupano della comunicazione con il back office e, se il display risulta offline, avvia la visualizzazione dell'ultima playlist salvata.
    \item monitor.js: questa classe si occupa di aprire la socket verso il back office e di restare in ascolto su questa, alla ricezione dei messaggi chiama i metodi necessari.
    \item speedtest.js: questa classe viene invocata quando si riceve una richiesta per valutare lo stato della rete dal back office.
\end{itemize}

\subsection{Documentazione WebOs Signage}\label{webos_doc}

Dopo l'analisi dell'applicazione preesistente è stata studiata la documentazione (disponibile in \cite{LgDoc}) dei dispositivi LG.

Come detto in \ref*{api} sono state analizzate le diverse interfacce messe a disposizone dal sistema per la comunicazione tra il browser e il sistema operativo; le librerie disponibili sono: 
\begin{itemize}
    \item SCAP API: un set di interfacce specifiche per WebOs Signage, la versione di WebOs dedicata ai sistemi di digital signage, \tomodify{suddivise in diverse classi a seconda del loro uso}. Questo è il set scelto per lo sviluppo poiché, sebbene non sia il più recente, è l'unico compatibile con tutti i device di digital signage di LG e che abbia un set ampio di interfacce tale da coprire i requisiti dell'applicazione;
    \item IDCAP API: è il nuovo standard di API di LG che ha come obbiettivo quello di rendere univoche le interfacce per le diverse versioni di WebOs sia quella per il digital signage che quella per le Tv commerciali. Nonostante questo set sia quello raccomandato da LG è supportato solamente da WebOs Signage 6.0 e successivi;
    \item Harmony API: una libreria, specifica per WebOs Signage, contenente le interfacce per la comunicazione con alcuni dispositivi esterni come ad esempio stampanti, sensori NFC e infrarossi;
    \item CustomJS API: questo set aggiunge alcune interfacce mancanti alla libreria SCAP. Questa libreria è aggiunta all'applicazione sviluppata al fine di espanderne le funzionalità (si veda \ref*{aggiunte}).
\end{itemize}

Sono state anche studiate le informazioni hardware e software dei dispositivi cercando di capire quali fossero \tomodify{le possibilità} minime comuni a tutti. Dal momento che le componenti software e hardware sono molto diverse tra loro sono stati presi in considerazione solo i dispositivi che sopportano almeno WebOs signage 4.0. Di seguito sono riportate le specifiche e le versioni dei linguaggi di programmazione supportate che sono state definite dopo l'analisi.

\begin{center}
\begin{tabular}{ |l|r| } 
     \hline
     HTML & versione 5 \\ 
     CSS & versione 3 \\ 
     JavaScript & versione 1.6+ \\ 
     \hline
     Web Engine & Chrome 53 \\ 
     HTTP, HTTPS & \checkmark \\ 
     XMLHttpRequest (AJAX) & \checkmark \\ 
     JSON & \checkmark \\ 
     \hline
     RAM & 2.0 GB \\
     Memoria & 8.0 GB\\
     Risoluzione & 1920x1080\\
     \hline
\end{tabular}
\end{center}

\section{Scrittura delle classi JavaScript}

\subsection{Codice delle chiamate alle API}
Le chiamate API per i dispositivi LG sono di due tipi, le prime ( Listing \ref*{lst:apiget} ) servono per chiedere delle informazioni al sistema operati come ad esempio il numero seriale, il mac address o il livello del volume, le seconde (Listing \ref*{lst:apipost}) servono per modificare delle impostazioni di sistema come il volume, lo stato del dispositivo (accensione e spegnimento) o la rotazione dello schermo. In entrambi i casi vengono passate due funzioni dette di callback che saranno eseguite in caso di successo o fallimento della chiamata, le chiamate di \tomodify{modifica del sistema} necessitano inoltre di una struttura contenente i nuovi valori da impostare.

In risposta viene passato un oggetto alle funzioni di callback, in listing \ref*{lst:returnsample} vengono mostrati due esempi: uno in caso di successo, uno di fallimento.

\lstinputlisting[caption={Esempio chiamata API WebOS.}, label={lst:apiget}, language=JavaScript, firstline=0, lastline=18]{listings/svolgimento/api_sample.js}
\lstinputlisting[caption={Esempio chiamata API WebOS.}, label={lst:apipost}, language=JavaScript, firstline=37, lastline=54]{listings/svolgimento/api_sample.js}
\lstinputlisting[caption={Esempi dei messaggi di risposta.}, label={lst:returnsample}, language=JavaScript, firstline=20, lastline=34]{listings/svolgimento/api_sample.js}

\tomodify{A causa della natura asincrona di queste funzioni è stato necessario spesso gestire l'attesa delle risposte e la sincronizzazione con il resto del codice.} Si è inoltre cercato di ridurre il numero di chiamate alle API, per diminuire in maniera sostanziale i ritardi causati da queste, salvando i dati destinati a perdurare nel tempo nel LocalStorage: un oggetto definito dal browser che permette di salvare in maniera temporanea delle coppie di oggetti chiave-valore. Tuttavia, non essendo assicurata dal browser la \tomodify{perseveranza} di questo oggetto sono stati implementati tutti i controlli necessari. In \ref*{freestorage} saranno evidenziati i problemi relativi alla capacità del localStorage e alle soluzioni trovate al fine di bilanciare la velocità di esecuzione e la disponibilità dello spazio di memoria.

\subsection{Flusso principale}

La prima funzione invocata al momento dell'avvio è \jscode{start()} definita in \jscode{main.js} che, come prima cosa controlla se sia disponibile un'aggiornamento dell'applicazione o del firmware, in tal caso scarica l'aggiornamento e, dopo aver riavviato il dispositivo, lo installa; in caso non siano presenti aggiornamenti o il download non è riuscito invia una richiesta al server per verificare se il display sia già stato associato in caso affermativo riceve le informazioni relative al contenuto da mostrare, altrimenti viene generato un codice per svolgere l'associazione tramite il portale online. Nel caso in cui il display risulti offline all'avvio viene controllato quale sia l'ultimo contenuto salvato sul database e, se disponibile, viene mostrato fino a che non sia possibile collegarsi con il server.

Viene inoltre avviato il controllo periodico, mediante la \tomodify{funzione} \jscode{setInterval}, della connessione (Listing \ref*{lst:checkconnection}) \tomodify{inviando un messaggio a un URL e controllando lo stato della risposta.}

\lstinputlisting[caption={Controllo dello stato della connesione.}, label={lst:checkconnection}, language=JavaScript]{listings/svolgimento/checkconnection.js}

\tomodify{Durante il flusso principale viene mantenuta aperta una socket di comunicazione con il web server in mondo da poter ricevere, in caso di cambiamenti che il creatore di contenuti ha fatto nel backoffice o dovuti a fattori esterni (meteo, posizione, orario), un messaggio contenente le operazioni che il client deve effettuare ed eventuali nuove playlist da mostrare.}


\section{Cambiamenti di logiche e scelte implementative}
\subsection{Lettura e scrittura dei database} \label{database}

All'arrivo dei dati dall backoffice o in caso di un cambiamento della playlist o l'inserimento del plugin tutti i dati sono salvati in un database in modo da assicurare che anche nel caso di assenza di rete l'ultimo contenuto mostrato sia in ogni caso disponibile.

Non essendo possibile l'utilizzo di un database SQL è stata usata la libreria Dixie.js \cite{dixie} che permette di salvare i dati necessari in un file di testo, correttamente formattato, e accedere i dati come chiave - valore. \note{perchè cazzo ogni volta scriviamo tutto il file da capo anzi che aggiungere una entry?}

Durante lo studio della documentazione LG è stato osservato che il buffer di memoria per la lettura e scrittura di un file è solo di 10 KB; è stato quindi necessario implementare le funzioni di scrittura e lettura di un file in maniera ricorsiva. Dal momento che il numero di chiamate risultanti è necessariamente elevato e i tempi di esecuzione intorno ai 30s è stato inoltre deciso di implementare le due funzioni in modo asincrono rispetto al resto del flusso di esecuzione. 

Nonostante questo il carico di lavoro risulta piuttosto elevato e di conseguenza i rallentamenti dei contenuti mostrati risultano comunque evidenti durante la scrittura del database. 

\lstinputlisting[caption={Scrittura ricorsiva del database.}, label={lst:dbwrite}, language=JavaScript]{listings/svolgimento/databasewrite.js}

In Listing \ref*{lst:dbwrite} sono mostrate le due funzioni usate per la scrittura del database; Inizialmente viene eliminato il file precedentemente salvato e, in caso di successo,prima viene fatto un encoding in bytes della stringa rappresentante il contenuto del file e successivamente la funzione di \jscode{doStoreFile()} scrive 10KB alla volta nel sul file system.

\subsection{Cancellazione del localStorage} \label{freestorage}

I dati relativi alle playlist e ai plugin vengono salvati, oltre che sul database, anche nel localStorage in modo da ridurre i tempi di lettura dei dati e avere un minor numero di letture del database. 

In seguito ai test è stato osservato che la memoria disponibile del localStorage è relativamente limitata, intorno ai 5 MB, ed è stato quindi necessario gestire tutte le scritture e le conseguenti cancellazioni dei dati salvati in questa memoria. È stato fatto in modo che solo i dati necessari al contenuto mostrato al momento restino salvati nel localStorage per permettere un rapido accesso e vengano cancellati al momento del cambio del contenuto prestando particolare attenzione nel mantenere i dati relativi alle immagini e video precedentemente scaricati in modo da non doverli scaricare più volte così da mantenere libera la memoria del dispositivo e ridurre le chiamate e i tempi di esecuzione al momento del cambio di contenuto. 

\subsection{Gestione della connessione}
\subsection{Gestione dei timer}
\subsection{Aggiornamento del firmware di sistema e dell'applicazione}\label{update}
\subsection{Gestione input del telecomando}

\section{Fase di testing}


